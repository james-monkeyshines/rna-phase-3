#include "Tree/SimulationTree.h"
#include "Tree/SimulationNode.h"

#include "Util/FileParser.h"
#include "Util/statlib.h"
#include "Tree/TreeMap.h"
#include "Models/Model.h"

#include <iostream>
#include <math.h>
#include <float.h>
#include <limits>

using namespace std;

SimulationTree::SimulationTree() : Tree() {
}


SimulationTree::SimulationTree( ParametersSet& parameters ){
    //whether or not the tree will be automatically generated, a filename must
    //be provided either to read the tree provided by the user or to save the
    //tree randomly generated by SimulateTree
    string treeFileName = parameters.stringParameter("Tree file");
    if ( parameters.boolParameter("Generate tree") ){
        ofstream treeOutput;
        FileParser::confirmOpenFile( treeOutput, treeFileName, true );
        generate(parameters);
        treeOutput << toString( false ) << ";" << endl;
        treeOutput.close();
    }
    else{
        ifstream treeInput;
        treeInput.open( treeFileName.c_str() );
        string stringTree;
        FileParser::readTree( treeInput, stringTree);
        if ( stringTree.length() == 0 ){
            cerr << "Error while reading the tree in the file : "
                 << treeFileName << endl;
            exit(EXIT_FAILURE);
        }
        treeInput.close();
        constructFromString( stringTree );
    }
    pmodel = NULL;
}


void SimulationTree::constructFromString( string stree ) {
    // Create a depth map of the tree
    TreeMap map( stree );

    // Create the nodes
    root = new SimulationNode( map, this );

    createIndex();
}

void SimulationTree::recursiveConstruct( unsigned int cladeSize,
                                SimulationNode* parent, double beta ){
    Singleton < randombox > & randomBox = Singleton < randombox >::instance();
    assert(cladeSize >= 2);
    
    unsigned int split;
    unsigned int i;
    
    unsigned int mid = cladeSize/2;
    double prob[mid]; ////P(split==i)=P(split==cladeSize-i) => use only half an array
    double sum;
    double rnd;
    bool inv;
        
    switch( cladeSize ){
        case 2:
            split = 1;
        break;
        case 3:
            if (randomBox.ran()<.5) split = 1; else split = 2;
        break;
        default: 
            if ( beta == numeric_limits<double>::infinity() ){  //medium tries
                split = 0;
                while (split==0){
                    for ( i = 0; i < cladeSize; ++i ){
                        if (randomBox.ran()<.5) ++split;
                    }
                    if (split==cladeSize) split = 0; //0 and cladeSize are invalid
                }
            }
            else{
                if ( beta == -2.0 ){ //comb limit
                    if (randomBox.ran()<.5) split = 1; else split = cladeSize-1;
                }
                else{ //general case, P(split==i) is proportional to [Gamma(beta+i)Gamma(beta+cladeSize-i)]/[Gamma(i+1)Gamma(cladeSize-i+1)]
                    sum = 0.0;
                    for ( i = 0; i < mid; ++i ){
                        prob[i] = exp( lgamma(beta+(double)(i+2))+lgamma(beta+(double)(cladeSize-i))
                                       -lgamma((double)(i+2))-lgamma((double)(cladeSize-i)) );
                        sum += prob[i];
                    }
                    if ( (cladeSize%2) == 0 ){ //cladeSize is even, for cladeSize==4, c = prob[0] + prob[1] + prob[2] = sum + sum - prob[1]
                        sum += sum - prob[mid-1]; //with 2*sum, the middle split is counted twice. Remove it once
                    }
                    else {  //cladeSize is odd, for cladeSize==4, sum = prob[0] + prob[1] + prob[2] + prob[3]
                        sum += sum;
                    }
                    inv = false;
                    rnd = randomBox.ran();
                    if (rnd>.5){
                        inv = true;
                        rnd -= .5;
                    }
                    rnd = rnd*sum;
                    i = 0;
                    rnd -= prob[i];
                    while (rnd > 0.0){
                        ++i;
                        assert(i < mid);
                        rnd -= prob[i];
                    }
                    if (!inv) split = i+1; else split = cladeSize - i - 1;
                }
            }
        break;
    }

    //prepare the two subtrees
    SimulationNode* node1;
    SimulationNode* node2;    
    //at least two element in the low/left split?
    if ( split>1 ){
        node1 = new SimulationNode( this );
        recursiveConstruct( split, node1, beta );
    }
    else{
        node1 = new SimulationNode( "", this );
    }
    if ( cladeSize-split>1 ){
        node2 = new SimulationNode( this );
        recursiveConstruct( cladeSize-split, node2, beta );
    }
    else{
        node2 = new SimulationNode( "", this );
    }
    add( node1, parent, -1.0 );
    add( node2, parent, -1.0 );
}


void SimulationTree::generateBetaSplitTopology( double beta, unsigned int numberLeaves,
                                                unsigned int numberLeaves2 ){
    //method from David Aldous in "Random Discrete Structures":
    //"Probability Distribution on Cladograms" (1996).
    
    root = new SimulationNode( this );
    if (!numberLeaves2){
        recursiveConstruct( numberLeaves, (SimulationNode*)root, beta );
        outgroup = NULL;
        char label[10];
        label[0]='s';
        char * num = label+1;
        unsigned int indice = 1;
        for (vector<BasicNode*>::iterator iter = nodeRefVector.begin(); iter != nodeRefVector.end(); ++iter){
            if ( (*iter)->isLeaf() ){
                sprintf(num,"%d", indice);
                (*iter)->changeLabel( label );
                ++indice;
            }
        }
        assert(indice==numberLeaves+1);
    }
    else{
        //if a number of leaves is specified in an outgroup branch then fix the position of the first split
        SimulationNode* node1 = new SimulationNode( this );
        //call a recursive construction with the first split
        recursiveConstruct( numberLeaves-numberLeaves2, node1, beta );
        SimulationNode* node2;
        if (numberLeaves2==1){
            node2 = new SimulationNode( "", this );
        }
        else{
            node2 = new SimulationNode( this );
            //call a recursive construction with the nodes between [limit, 1.0]
            recursiveConstruct( numberLeaves2, node2, beta );
        }
        //set the outgroup
        outgroup = node2;
        add( node1, root, 1.0 );
        char label[10];
        label[0]='s';
        char * num = label+1;
        unsigned int indice = 1;
        for (vector<BasicNode*>::iterator iter = nodeRefVector.begin(); iter != nodeRefVector.end(); ++iter){
            if ( (*iter)->isLeaf() ){
                sprintf(num,"%d", indice);
                (*iter)->changeLabel( label );
                ++indice;
            }
        }
        assert(indice==numberLeaves-numberLeaves2+1);
        add( node2, root, 1.0 );
        label[0]='o';
        indice = 1;
        for (vector<BasicNode*>::iterator iter = nodeRefVector.begin(); iter != nodeRefVector.end(); ++iter){
            if ( (*iter)->isLeaf() && (*iter)->getLabel().empty() ){
                sprintf(num,"%d", indice);
                (*iter)->changeLabel( label );
                ++indice;
            }
        }
        assert(indice==numberLeaves2+1);
    }
}

void SimulationTree::createTopology( unsigned int topoId, ParametersSet& parameters,
                                     unsigned int numberSpecies, unsigned int numberOutgroupSpecies ){
    
    double beta=0.0;
    
    switch(topoId){
        case TOPO_YULE: beta = 0; break;
        case TOPO_UNI: beta = -1.5; break;
        case TOPO_BETA: if ( (parameters.stringParameter("Beta parameter")=="+infinity") ||
                             (parameters.stringParameter("Beta parameter")=="+inf") ||
                             (parameters.stringParameter("Beta parameter")=="inf") ){
                            beta = numeric_limits<double>::infinity();
                        }
                        else{
                            beta = parameters.doubleParameter("Beta parameter");
                        }
                        if (beta < -2.0){
                            cerr << "Error: the beta parameter for the beta-splitting must "
                                 << "be between -2.0 (included) and \"+inf\" (included)" << endl;
                            exit(EXIT_FAILURE);
                        }
                        break;
        default: assert(0);
    }
    generateBetaSplitTopology( beta, numberSpecies, numberOutgroupSpecies );
}


void SimulationTree::assignDates( BasicNode* node, const set<double> & speciationDates ){

    Singleton < randombox > & randomBox = Singleton < randombox >::instance();
    //dates are assigned randomly to all the possible candidates iteratively
    //(this "order" is important)
    //the first element is the node waiting, the second element is the father speciation date
    vector< pair<BasicNode*,double>* > waitingNodes;
    
    //a reverse iterator, we start with the oldest node and gt down to the leaf
    set<double>::const_reverse_iterator iter = speciationDates.rbegin();
    for ( list<BasicNode*>::iterator iterChild = node->getChildrenList().begin();
          iterChild != node->getChildrenList().end(); ++iterChild ){
        if (!(*iterChild)->isLeaf()){
            waitingNodes.push_back( new pair < BasicNode*, double >(*iterChild, *iter) );
        }
        else{
            (*iterChild)->setParentDistance( *iter );
        }
    }
    ++iter;
    while( iter != speciationDates.rend() ){
        assert( !waitingNodes.empty() );
        unsigned int chosenIndice = (unsigned int)( randomBox.ran() * (double)waitingNodes.size() );
        pair<BasicNode*, double>* chosen = waitingNodes[chosenIndice];
        BasicNode* chosenNode = chosen->first;
        chosenNode->setParentDistance( chosen->second - *iter );
        //add nodes if necessary (since chosen has to be removed try to re-use it)
        for ( list<BasicNode*>::iterator iterChild = chosenNode->getChildrenList().begin();
              iterChild != chosenNode->getChildrenList().end(); ++iterChild ){
            if (!(*iterChild)->isLeaf()){
                //overwrite waitingNodes[chosenIndice] first (== where chosen is pointing)
                if (chosen){
                    chosen->first = *iterChild;
                    chosen->second = *iter;            
                    chosen = NULL;
                }
                //if waitingNodes[chosenIndice] was already overwritten then add a new element
                //to the list of waiting nodes
                else{
                    waitingNodes.push_back( new pair < BasicNode*, double >(*iterChild, *iter) );
                }
            }
            //leaves are dealt with directly
            else{
                (*iterChild)->setParentDistance(*iter);
            }
        }
        //is chosen was not overwritten (ie only leaves under chosenNode) then delete
        //the pointer before losing it
        if (chosen){
            delete chosen;
            waitingNodes.erase(waitingNodes.begin()+chosenIndice);
        }
        ++iter;
    }
    assert( waitingNodes.empty() );
}

void SimulationTree::createBranchLengths( unsigned int branchId, ParametersSet& parameters,
                                     unsigned int numberSpecies, unsigned int numberOutgroupSpecies ){

    Singleton < randombox > & randomBox = Singleton < randombox >::instance();


    //set of variable for the birth and birth-death branch lengths
    double l;
    double m;
    double speciesSampling = 1.0;
    double outgroupSampling = 1.0;            
    double uni;
    double delta = 0.0;
    double bl;
    double phi = 0.0;
    double expVal = 0.0;
    double mom;
    set<double> speciationDates;
    set<double> speciationDatesOutgroup;
    double treeHeight;
    
    switch(branchId){
        case BRANCH_UNI: 
            double min,max;
            min = parameters.findParameter("Branch prior, lower bound") ?  parameters.doubleParameter("Branch prior, lower bound") : 0.0;
            max = parameters.doubleParameter("Branch prior, upper bound");
            for ( vector< BasicNode* >::iterator iter = nodeRefVector.begin();
                  iter!= nodeRefVector.end(); ++iter ){
                (*iter )->setParentDistance( (randomBox.ran() * (max-min)) + min );
            }
        break;
        case BRANCH_EXP:
            double param;
            param = parameters.doubleParameter("Branch prior, exponential parameter");
            for ( vector< BasicNode* >::iterator iter = nodeRefVector.begin();
                  iter!= nodeRefVector.end(); ++iter ){
                (*iter )->setParentDistance( randomBox.sexp()/param );
            }
        break;
        case BRANCH_PURE_BIRTH: case BRANCH_BIRTH_DEATH:
            treeHeight =  parameters.doubleParameter("Tree height");
            l = parameters.doubleParameter("Birth rate");
            //read death rate if birth-death process, else death rate = 0.
            m = (branchId == BRANCH_PURE_BIRTH) ? 0 : parameters.doubleParameter("Death rate");
            //sampling effect?
            if ( parameters.findParameter("Species sampling") ){
                speciesSampling = parameters.doubleParameter("Species sampling");
                outgroupSampling = speciesSampling;
            }
            if ( numberOutgroupSpecies && parameters.findParameter("Outgroup sampling") ){
                outgroupSampling = parameters.doubleParameter("Outgroup sampling");                
            }
            if ( (speciesSampling < 0.0) || (speciesSampling > 1.0) || (outgroupSampling < 0.0) || (outgroupSampling > 1.0) ){
                cerr << "Error, a percentage between 0 and 1.0] is expected for the sampling parameter" << endl;
                exit(EXIT_FAILURE);
            }
            
            //(Yang & Rannala, 1997) gave the formulae to get a sample of the speciation dates
            //corresponding to the birth-death process with sampling, let's sample and sort in a set
            //date for the root is 1.0, for the tips date is 0.0
            //if sampling goes down then internal branches get shorter
            delta = m-l;
            if (delta!=0.0){                   //we compute phi (equation 16)
                expVal = exp(delta);
                phi = ( speciesSampling * l * ( expVal - 1.0 ) ) + ( delta * expVal );
                phi = phi / (expVal - 1.0);
            }
            if (numberOutgroupSpecies){
                //there are numberSpecies - numberOutgroupSpecies - 1 dates for "normal species"
                for ( unsigned int i=0; i < numberSpecies - numberOutgroupSpecies - 1; ++i ){
                    uni = randomBox.ran();
                    if (delta != 0.0){       //(use equation 15)
                        mom = phi - uni * speciesSampling * l;
                        bl = log( mom ) - log( mom - (uni*delta) );
                        bl = bl / delta;
                    }
                    else{                    //(use equation 17)
                        bl = uni / ( ( (1.0-uni) * speciesSampling * l ) + 1 );
                    }
                    speciationDates.insert( bl*treeHeight );
                }
                //recompute phi if necessary
                if( (delta!=0.0) && (speciesSampling != outgroupSampling) ){
                    phi = ( outgroupSampling * l * ( expVal - 1.0 ) ) + ( delta * expVal );
                    phi = phi / (expVal - 1.0);
                }
                for ( unsigned int i=0; i < numberOutgroupSpecies - 1; ++i ){
                    uni = randomBox.ran();
                    if (delta != 0.0){       //(use equation 15)
                        mom = phi - uni * outgroupSampling * l;
                        bl = log( mom ) - log( mom - (uni*delta) );
                        bl = bl / delta;
                    }
                    else{                    //(use equation 17)
                        bl = uni / ( ( (1.0-uni) * outgroupSampling * l ) + 1 );
                    }
                    speciationDatesOutgroup.insert( bl*treeHeight );
                }
                assert(outgroup);
                BasicNode* notOutgroup = root->getChild(0);
                if (notOutgroup==outgroup){
                    notOutgroup = root->getChild(1);
                }
                notOutgroup->setParentDistance(treeHeight - *(speciationDates.rbegin()));
                outgroup->setParentDistance(treeHeight - *(speciationDatesOutgroup.rbegin()));
                assignDates( notOutgroup, speciationDates );
                assignDates( outgroup, speciationDatesOutgroup );
            }
            else{
                //there are numberSpecies - 2 dates (+ the last date is tree height)
                for ( unsigned int i=0; i < numberSpecies - 2; ++i ){
                    uni = randomBox.ran();
                    if (delta != 0.0){       //(use equation 15)
                        mom = phi - uni * speciesSampling * l;
                        bl = log( mom ) - log( mom - (uni*delta) );
                        bl = bl / delta;
                    }
                    else{                    //(use equation 17)
                        bl = uni / ( ( (1.0-uni) * speciesSampling * l ) + 1 );
                    }
                    speciationDates.insert( bl*treeHeight );
                }
                speciationDates.insert(treeHeight);
                assignDates( root, speciationDates );
            }
        break;
        default: assert(0);
    }
}


void SimulationTree::generate( ParametersSet& parameters ){


    string generatingModel = parameters.stringParameter("Generating model");
    TopoID topoId = NB_TOPO_MODEL;
    BranchID branchId = NB_BRANCH_MODEL;
    if (generatingModel == "Yule process"){
        topoId = TOPO_YULE;
        branchId = BRANCH_PURE_BIRTH;
    }
    if (generatingModel == "Birth-death process"){
        topoId = TOPO_YULE;
        branchId = BRANCH_BIRTH_DEATH;
    }
    if (generatingModel == "Beta-splitting process"){
        topoId = TOPO_BETA;
    }
    if (generatingModel == "Uniform process"){
        topoId = TOPO_UNI;
    }
    if (topoId == NB_TOPO_MODEL){
        cerr << "Unrecognized generating model: " << generatingModel << endl;
        exit(EXIT_FAILURE);
    }
    if (branchId == NB_BRANCH_MODEL){
        string branchPrior = parameters.stringParameter("Branches prior");
        string testStr;
        testStr = "Uniform";
        if( branchPrior==testStr ){
            branchId = BRANCH_UNI;
        }
        testStr = "Exponential";
        if( branchPrior==testStr ){
            branchId = BRANCH_EXP;
        }
        testStr = "Pure-birth process";
        if( branchPrior==testStr ){
            branchId = BRANCH_PURE_BIRTH;
        }
        testStr = "Birth-death process";
        if( branchPrior==testStr ){
            branchId = BRANCH_BIRTH_DEATH;
        }
        if (branchId == NB_BRANCH_MODEL){
            cerr << "Unrecognized prior for the branch lengths" << endl;
            exit(EXIT_FAILURE);
        }
    }
    else{
        if (parameters.findParameter("Branches prior")){
            cerr << "Prior on branches need not be specified with the " << generatingModel << endl;
            exit(EXIT_FAILURE);
        }
    }
    unsigned int numberSpecies = parameters.intParameter("Number of species");
    unsigned int numberOutgroupSpecies = 0;
    if ( parameters.findParameter("Number of species in the outgroup") ){
        numberOutgroupSpecies = parameters.intParameter("Number of species in the outgroup");
    }
    if (numberOutgroupSpecies>=numberSpecies){
        cerr << "\"Number of species in the outgroup\" cannot be bigger than \"Number of species\"..." << endl;
        exit(EXIT_FAILURE);
    }
    createTopology( topoId, parameters, numberSpecies, numberOutgroupSpecies );
    createIndex();
    createBranchLengths( branchId, parameters, numberSpecies, numberOutgroupSpecies );
}




void SimulationTree::simulate( const vector<unsigned int> length ) {

    assert( pmodel );

    Singleton < randombox > & randBox = Singleton < randombox >::instance();

    unsigned int numberModels = length.size();    

    //create the category vector (at each site choose a component of the
    //mixture model, usually the discrete gamma category)
    categories.resize(numberModels);
    vector<double> propCat;
    for ( unsigned int modelId = 0; modelId < numberModels; ++modelId ) {
        categories[modelId].reserve(length[modelId]);
        propCat.resize(pmodel->getNumberRatesCategories(modelId));
        double cumul = 0.0;
        for ( unsigned int i = 0; i< propCat.size()-1; ++i ){
            cumul += pmodel->getRateCategoryProbability( i, modelId );
            propCat[i] = cumul;
        }
        propCat.back()=1.0;
        double number;
        for ( unsigned int site = 0; site < length[modelId]; ++site ) {
            /* assign a mixture category */
            number = randBox.ran();
            unsigned int cat = 0;
            while ( number > propCat[cat] ) ++cat;
            categories[modelId].push_back(cat);
        }
    }
    vector< vector<unsigned int> > junk;
    ((SimulationNode*)root)->simulate( categories, junk );
}


void SimulationTree::printSequenceTable( ostream & out ) {
    out << "#discrete rate category" << endl;
    for ( unsigned int modelId = 0; modelId < categories.size(); ++modelId ) {
        out << '#';
        for ( unsigned int site = 0; site< categories[modelId].size(); ++site ){
            out << categories[modelId][site] + 1 << ' ';
        }
    }
    out << endl << endl;
    //output internal nodes
    for ( vector<BasicNode*>::iterator iter = nodeRefVector.begin();
          iter != nodeRefVector.end(); ++ iter ){
        if ( !(*iter)->isLeaf() ){
            out << '#' << ((SimulationNode*)(*iter))->toString() << endl;
            for (unsigned int modelId = 0; modelId < categories.size(); ++modelId){
                const vector<unsigned int> & sequence =
                    ((SimulationNode*)(*iter))->getSequence(modelId);
                assert(sequence.size()==categories[modelId].size());
                out << '#';
                for (unsigned int site = 0; site< sequence.size(); ++site){
                    out << pmodel->getSymbol(sequence[site],modelId);
                }
                out << endl;
            }
            out << endl;
        }
    }
    for ( vector<BasicNode*>::iterator iter = nodeRefVector.begin();
          iter != nodeRefVector.end(); ++ iter ){
        if ( (*iter)->isLeaf() ){
            out << (*iter)->getLabel() << endl;            
            for (unsigned int modelId = 0; modelId < categories.size(); ++modelId){
                const vector<unsigned int> & sequence =
                    ((SimulationNode*)(*iter))->getSequence(modelId);
                assert(sequence.size()==categories[modelId].size());
                for (unsigned int site = 0; site< sequence.size(); ++site){
                    out << pmodel->getSymbol(sequence[site],modelId);
                }
                out << endl;
            }
            out << endl;
        }
    }
}


void SimulationTree::loadModel( Model * pmodel ) {
    assert ( this->pmodel == NULL );
    this->pmodel = pmodel;
}



